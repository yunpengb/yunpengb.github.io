[{"title":"使用Pyunit构建一个灵活的全自动测试平台","date":"2017-10-20T03:40:00.000Z","path":"2017/10/20/build_platform_by_pyunit/","text":"&emsp;&emsp;主要讨论的话题： 方案背景 方案实现 一、方案背景掌握python脚本的编写，希望通过使用简单的框架，实现全自动化测试 &emsp;&emsp;1.1 方案产生 产品测试的需求分析中，发现所有的测试步骤都可以通过python自动化控制。尤其是HTX工具可以使用pywin32控制，射频仪表可以通过pyvisa控制。 已经有一些通过python实现好的单个脚本的话，需要简单改写为Pyunit的格式。 使用pyunit做执行框架，使用开源的HTMLTestRunner作为测试报告生成工具 &emsp;&emsp; 1.2 方案简介a. 什么是Pyunit 简介：Pyunit是专业单元测试框架，通过断言方法，判断测试结果。 优雅简洁，被设计用于白盒测试。但是由于它足够简单，我认为可以用它编写更复杂一点点的脚本，用于作产品测试。 背景：Pyunit是Python版本的Junit, 隶属于Xunit系列，XUnit系列里最有名的是Junit Junit是一款开源框架，在业界是单元测试的标杆。 Pyunit大概出现于1999年左右，于2002年在python2.1往后的版本中被官方收录（python始于1989年，往后数第13年），成为官方集成的内建包。往后每个官方版本安装之后，直接可以import unittest。c.用白盒测试框架来测黑盒真的好吗其实Pyunit本身是用来写白盒测试的，我也一度觉得似乎用的工具不太匹配，很low，很不专业，后来逐渐改变了这种想法。测试活动的中心目的是，管理好测试的过程和结果，至于工具，尽力而为，只要能达到测试目的的工具，就是好工具。在有余力的时候，可以继续研究和转移到更高效的测试框架上。 &emsp;&emsp; 1.3 Pyunit的特点： 批量处理能力 Pyunit像一顶机关枪，只要有足够的子弹，就可以持续射击。适合组织批量执行case。 二元扁平结构 Pyunit使用的时候，分为两部分code: 执行器部分和测试用例部分，建议两部分分开，定义好接口后，分层管理code,这样单独修改某个文件不会牵连其他code，方便code管理和维护。测试用例部分建议做总体的设计和优化，这样方便迭代和扩展用例 Pyunit强在用例管理，注意做好单个脚本的架构设计和质量控制 Pyunit并不是具有魔力的万金油， 它依赖于测试用例code部分的质量，所以作为测试脚本的开发和维护者，需要做好case本身的细节管理。包测试需求量化，和测试脚本调试以及版本控制。这些都做到，就可以顺畅的跑测试，并且以后扩展case也不难了。 成熟、高质量的单个脚本，是实现系统的关键 只有大量实现好并且调试通过的单个用例，才可以使用Pyunit框架，将它们串联成一串弹夹，然后如机关枪般串联发射。 测试组特性 Pyunit可通过定义类来实现测试用例的集合，每个类是一个测试组，每个类方法是一个case。 内个case 通过断言语句实现最终结果的判断。 丰富的初始化和扫尾功能 支持单个用例前后的初始化操作和扫尾操作， 也支持整个测试组前后的初始化操作和扫尾操作 二、方案实现2.1 一定要有详细的测试需求：&emsp;&emsp;自动化没有详细的测试需求就是扯淡，测试需求是测试的基本输入，没有之一。 下面是一个例子：12345678910111213141516171819202122Version: 17Author: 刘德华Create Time: 1999-01-01Update Time: 1999-08-08Setup Need: TAD-PC \\ LMP \\ VLAN258 \\ FSV \\ RF cable \\ Power Switch AHFB 5Mhz带宽，下行载波的射频性能中的ACLR指标检查1. AHFB上电2. 等待40秒，此时应该开机结束，可以ping通101.1的IP地址3. 初始化HTX，等待同步结束，等待5秒4. 建立第一路的TX载波，频率为1962.5Mhz5. 等待10秒，此时载波应该处于稳定状态6. 通过GPIB接口连接罗德施瓦茨的FSV，复位FSV7. FSV进入Lte Mode8. FSV设置当前测量频率为1962.5Mhz，带宽为5Mhz9. FSV设置使用外部参考信号，并设置频率为10Mhz信号10.FSV设置使用连续测量模式11.FSV设置外部线损12.FSV读取一次ACLR结果13.通过ssh连接，读取命令dapd -stat 0的返回结果13.删除第一路的TX载波14.以上操作中没有报错，且ACLR的值小于-45db 则为PASS，否则为FAIL 通过这个例子，可以看到 测试需求是一次操作的真实写照，是一个执行清单，量化而具体，不管手动还是自动执行，均可以照着操作。 如果可能，在记录上最好再加上测试环境的信息，越丰富越好，比如依赖的硬件设备（TADX\\系统模块\\时钟盒子），需要几个DUT参与测试, 是否需要DUT处在特殊的状态下，等等都要注明下。 每个case都需要清晰的测试预期，也就是Pass和Fail的判断准绳，如果没有，请标注好待观察，然后将多次测试的数据收集起来，作为经验值的输入信息。 2.2 根据需求，实现用例的脚本 有了上述的需求清单，再去实现单个python脚本就容易一些 新加入的测试用例需要几个有经验的同事一起review,大家多提意见，才可以集思广益，发现一些细节的疏漏，避免漏测和误测。 2.3 按照Pyunit的格式，集成为测试组下面是我实现的一个基本例子，里面也有log和HTML report功能。 12345678910111213141516from testGroup1 import *import unittestimport sysdef ak47(): suiteTest = unittest.TestSuite() suiteTest.addTest(txPerformance(&quot;tx_power_pipe1&quot;)) suiteTest.addTest(txPerformance(&quot;tx_Aclr_low_pipe1&quot;)) suiteTest.addTest(txPerformance(&quot;tx_Aclr_high_pipe1&quot;)) return suiteTestif __name__ == &apos;__main__&apos;: runner.run(ak47()) 测试组1的简单Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# -*- coding:utf-8 -*-import unittestfrom def1 import *from time import sleepimport timeclass txPerf(unittest.TestCase):# class TxPerf(object): @classmethod def setUpClass(cls): cls.lloogg = None # ==== log instance init ==== tim = timestamp() cls.lloogg = &quot;log\\\\&quot; + &quot;case_TxPerf_&quot;+ tim + &quot;.log&quot; # cls.lloogg = &quot;case_TxPerf.log&quot; msg = &quot;~~~~~~~~~~ Case Start [%s] at %s ~~~~~~~~~~&quot; % (&quot;TX_Performance&quot;,str(tim)) logAndPrint(msg,cls.lloogg) # ==== powerSupply instance init and power on ==== unit_power_on() sleep(2) msg = &quot;~~~ unit power on step Done ~~~&quot; logAndPrint(msg,cls.lloogg) # ~~~~~~~~ active 4 carrier ~~~~~~~~ for pipe in range(4): activeTxCarr(pipe+1) sleep(2) msg = &quot;============ Pipe %d Active Tx OK ============&quot; % (pipe+1) logAndPrint(msg,cls.lloogg) @classmethod def tearDownClass(cls): sleep(1) attempts = 0 allrecover = False while attempts &lt; 2 and not allrecover: try: killnoUseprocess() allrecover = True except: print &quot;error happen in clear environment for %d time &quot; % attempts attempts += 1 sleep(3) # ==== power down ==== unit_power_down() # ==== log time ==== tim = timestamp() msg = &quot;~~~~~~~~~~ Case ShutDown [%s] at %s ~~~~~~~~~~&quot; % (&quot;TX_Performance&quot;,str(tim)) logAndPrint(msg,cls.lloogg) def setUp(self): print &quot;===case init...&quot; sleep(1) pass def tearDown(self): print &quot;===case clear...&quot; sleep(0.3) pass def tx_power_pipe1(self): readpower = 37.2 txp = readpower msg = &quot;AHFB Tx Power low should below 36 and 38&quot; print msg sleep(1) msg = &quot;Test Over, get tx power on pipe1 is &quot;+ str(readpower) logAndPrint(msg,self.lloogg) assert 36 &lt; txp &lt; 38 , &quot;power should between 36 and 38&quot; def tx_Aclr_low_pipe1(self): readAclrLow = -56 msg = &quot;aclr low should below -45&quot; print msg sleep(1) msg = &quot;Test Over, get tx aclr low on pipe1 is &quot;+ str(readAclrLow) logAndPrint(msg,self.lloogg) assert readAclrLow &lt; -45 def tx_Aclr_high_pipe1(self): readAclrHigh = -34 msg = &quot;aclr low should below -45&quot; print msg sleep(1) msg = &quot;Test Over, get tx aclr high on pipe1 is &quot;+ str(readAclrHigh) logAndPrint(msg,self.lloogg) assert readAclrHigh &lt; -45 if __name__ == &quot;__main__&quot;: unittest.main() 2.4 编写框架，应该注意的事情： 建议将每个测试组，放入不同的py文件，方便code管理。 每个测试组起名字的时候，最好使用容易理解，独立的名字 在测试组的类里，需要仔细想清楚初始化和扫尾需要做的事情，避免拖沓和无意义的操作。 通过以下4个对象完成前后场景的高级功能： setUpClass 这个类方法，负责测试组前的初始化动作。适合放入“所有测试case只需要干一次的事情”（比如Radio开机上电） tearDownClass 这个类方法，负责测试组后的扫尾动作。适合放入“所有case都结束的时候执行的动作” （比如Radio下电，比如发送邮件通知测试者，测试结束） setUp 这个成员函数，负责每个case 执行前的初始化动作。适合放入“对于每个case都需要的初始动作，建议尽量少放入动作” tearDown 这个成员函数，负责每个case执行后的扫尾动作。适合放入“对于每个case执行完后都需要的动作，一般为清理环境的动作，尽量少放入动作” 三、 其他注意事项： 在执行“执行脚本”的时候，会在终端中打印当前测试的实时状态： 一个点表示Pass 一个大写的F表示Fail 一个大写的E表示异常，说明case非正常结束，可以在后面的报告中查看提示信息 建议在脚本里，尽量少用Print 函数，因为所有的打印信息都会被收集到HTML报告中，会显得很臃肿而且杂乱。一个优秀的测试系统，应该把必要的信息（case是Pass还是Fail）放在测试报告里，其他的详细信息（测试的过程，步骤的record,关键位置的mark信息）全部收录到测试log中。 再次强调，这个系统依赖高质量的单个测试脚本，每个测试case应当经过几轮的验证和过滤再加入到测试系统里。否则不仅是一场不停修改错误的折磨人的循环，同时也是浪费大家的时间。对于测试活动来说，时间很重要，规则很重要。 我在pyunit_demo\\box 下面放了一个 check_set1.py 作为一个后悔药的例子 ，如果单独的脚本依然有问题，还是有办法在短时间内做debug检查的，那就是将测试组改写成独立的类，然后单独的调用它，观察过程是否正常，是否会报错。 3.3 最后把pyunit的官方文档附上，还有中文版哦pyunit.sourceforge.net/ 四、以后有时间，需要研究下，下面的高级工具 测试框架 Robot framework 流行的CI外挂 Jenkins","tags":[]},{"title":"将Notepad++ 配置成Python IDE","date":"2017-09-25T13:40:00.000Z","path":"2017/09/25/config_notepad_to_pyide/","text":"一、必要条件 安装好Python解释器 安装好Notepad++ ,目前建议安装X86-7.4.2 版本，X64的版本没有插件管理器，且X86-7.4.2版本以上的版本暂时也没有插件管理器。 二、配置nppexec插件 安装nppexec 插件点击菜单里的插件–plugin manager —show piugin manager , 选择nppexec插件安装。中间可能会碰到升级plugin manager的提示。有时候会升级多次。 配置运行python的命令 点击插件– nppexec–execute在弹出的界面里，command里输入123npp_savecd &quot;$(CURRENT_DIRECTORY)&quot;C:\\Python27\\python.exe &quot;$(FILE_NAME)&quot; 将这个动作保存，名字起为py27 然后打开高级设置 为刚才编辑的命令集绑定一个项目run py27，上面的“Place to the Macros submenu”可勾可不勾 然后再为这个项目绑定一个快捷键 点击菜单： 运行—管理快捷键 —plugin commands ，找到Plugin commands 选项卡下的run py27,为它定义一个快捷键。至此大功告成。以后每次编写程序，按下快捷键，即可在窗口直接看到运行结果。","tags":[]},{"title":"在Ubuntu上搭建一个自己的Dokuwiki","date":"2017-09-24T03:40:00.000Z","path":"2017/09/24/install_dokuwiki_on_ubuntu/","text":"一、 前言有一个wiki是很方便的，主要可以用来： 记录自己的项目活动相关信息 记录测试需求 记录备忘事项，方便其他人查看 加入评论，可以形成部分电子白板的功能 二、安装细节 首先需要有一个ubuntu主机，我选择的是16.04 64bit的桌面系统 在主机上安装apache2 1sudo apt-get install apache2 安装php5.6 $ sudo apt-get install python-software-properties $ sudo add-apt-repository ppa:ondrej/php $ sudo apt-get update $ sudo apt-get -y install php5.6 php5.6-mcrypt php5.6-mbstring php5.6-curl php5.6-cli php5.6-mysql php5.6-gd php5.6-intl php5.6-xsl php5.6-zip 安装结束后，查询php版本： php -v 安装Dokuwiki sudo wget https://download.dokuwiki.org/out/dokuwiki-c5525093cf2c4f47e2e5d2439fe13964.tgz –no-check-certificate 下载压缩包后，解压，然后将内容放在 /var/www/html/dokuwiki/下，然后修改dokuwiki文件夹的所有者为阿帕奇， sudo chown -R www-data:www-data /var/www/html/dokuwiki sudo chmod -R 707 /var/www/html/dokuwiki 浏览器输入http://localhost/dokuwiki/install.php 应该可以查看到新安装的提示页面。 配置Dokuwiki按照上述的流程，安装完成Dokuwiki后，理论上，ubuntu上apache2 这个process的owner就是www-data:www-data, 而dokuwiki文件夹的所有者也是www-data:www-data。所有的功能都是通过浏览器实现。后台apache2会根据wiki网页自动地生成页面文件，所以不需要wiki使用者再通过linux去维护这个服务。 三、 使用小技巧： 在浏览器的地址上后缀加上，aaa:bbb就会自动产生一个aaa文件夹，并在aaa文件夹下自动产生bbb页面，此时点击页面上的创建此页面，然后就顺利的完成了新建页面的动作。 dokuwiki有几款很好用的插件，插件可以通过浏览器安装，需要到插件下载页下载zip格式的插件，然后使用dokuwiki管理员页面的自定义插件选项卡上传，自动安装成功。 通过管理员的设置，可以隐藏很多按钮，让wiki的主界面简洁一些，隐藏媒体管理器，输入media即可。 dokuwiki有很强大的用户管理功能，可以设置分组，且可以设置查看权限。有效使用可以效率翻倍。 dokuwiki有很多强大的功能都是通过插件实现的，后面我再更新一个介绍插件的文章。","tags":[]},{"title":"WIN Python环境指南恢复指南","date":"2017-09-17T04:04:00.000Z","path":"2017/09/17/recover_python/","text":"一、恢复Python开发环境的场景 重装系统 转移到新的工作站 二、需要备份的材料 编辑器\\IDE （这个就不多说了） Python解释器套装（一般为Cpython） 三、Python解释器和依赖包的备份 Cpython解释器就到官网下载安装即可恢复 对于第三方库，如果你可以上网的话，做一个你的环境的备份的方法如下 cmd输入下面的命令 pip freeze &gt; requirements.txt 将环境下所有的第三方库重定向到requirements.txt 这个文件内，在新的PC上安装完解释器后，输入 pip install -r requirements.txt即可快速安装原来列出的第三方库 如果网络没法使用，备份的方法再议，可能需要打包工具","tags":[]},{"title":"MicroPython 访问DHT11获得温湿度数据","date":"2017-09-09T12:40:00.000Z","path":"2017/09/09/useMP_read_temp_from_DHT11/","text":"如题目的 获取数据 温度 湿度 demo需要的硬件 ESP8266开发板*1，预计TB售价20块不到 DHT11 温湿度传感器*1，预计TB售价3块 实验用的面包板*2和面包线几根 5k 欧姆的电阻一个，（按照DHT11的手册推荐使用） 组装方法如下图 实物图 这里比较好理解，电源供给从8266的3.3V连接带DHT11的vcc，地线从8266的GND连接到DHT11的GND，然后在本次说明中，dht11的data线和ESP8266的D2口（GPIO4）相连，这里的5K电阻是参考了DHT11文档中推荐的连接用上的、 读取温湿度的Code12345678910111213import dhtimport machinefrom time import sleepd = dht.DHT11(machine.Pin(4))d.measure()while True: sleep(1) print (&quot;temp is [%s]&quot; % str(d.temperature())) print (&quot;hum is [%s]&quot; % str(d.humidity())) print (&quot;\\r&quot;) sleep(1) 再次附上8266的PIN脚图","tags":[]},{"title":"Markdown 粘贴学习用","date":"2017-08-20T13:23:35.726Z","path":"2017/08/20/markdown_demo/","text":"导语： Markdown是一种轻量级的「标记语言」，它的优点很多 一，认识Markdown在刚才的导语里提到， 创始人语法说明 Markdown中文版语法说明 使用Markdown的优点 专注你的文字内容 轻松的导出HTML 专注 轻松 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码段hello world! 参考文献Te_Lee,「Markdown——入门指南」","tags":[]},{"title":"MarkDown 小总结","date":"2017-04-29T09:03:00.000Z","path":"2017/04/29/markdown_summary/","text":"放入文字超链接 [ESPyHarp](https://git/11) 放入图片![](http://oi.com/aa.jpg) 段落前空两格\\&emsp;\\&emsp; 另起一行在前一行的行尾加入多过2个空格 插入code方法是在code的上下一行各加上三个上标点 ``` 在 markdown 中显示 markdown 原文在特殊字符前加入\\即可，即阻止转义","tags":[]},{"title":"MicroPython ESP8266 操作指南","date":"2017-03-20T07:55:00.000Z","path":"2017/03/20/ESP_MicroPython_Guide/","text":"擦掉flashMicroPython的 intro 里1.4里有介绍。另外，如果是在win os下，擦除flash的命令大概是1esptool.py --port com3 erase_flash 刷入MicroPython 固件下载对应ESP8266的MicroPython固件的地址在这里 download ，你会得到类似esp8266-20170108-v1.8.7.bin 这样命名的文件。刷入方法在上面的1.4节也有介绍，主要就是依靠下面这句1esptool.py --port com3 --baud 115200 write_flash --flash_size=detect 0 esp8266-20170108-v1.8.7.bin 注意，我尝试过512k专属版，似乎不好用，所以还是使用长期稳定版比较好（每夜版没有试过）。 查看文件系统1234uos.listdir() # 查看路径下的文件uos.listdir(&apos;dir&apos;) #查看文件夹下的文件uos.getcwd() #查看当前目录, 根目录是&apos;&apos;uos.chdir() #改变当前目录 查看文件使用打开文件的方法123f = open(&apos;main.py&apos;, &apos;r&apos;)f.read()&quot;print(&apos;Welcome~&apos;)\\nprint(&apos;Hello!&apos;)\\n&quot; 删除文件1uos.remove(&apos;main.py&apos;) Software Reset在串口可用的时候，输入Ctrl + D 即可软复位 Hardware Reset断电时硬复位 常用工具 ESPyHarp 是一个可以给MP传输文件的java程序，win下使用，硬伤是无法快速便捷的中断com占用，导致使用起来不方便。webrepl client html是一个网页形式的文件传输工具，使用起来比较方便，每次连接一般是要输入密码（根据MP的设置来）.esptool这个上面都有说，python 公共库里集成了，使用pip安装1pip install esptool 已知问题利用http 按钮发送反馈的时候，不能使用360浏览器，它会拦截反馈信息 参考MicroPython官网介绍1论坛介绍2","tags":[]},{"title":"python 版的ESP控制端","date":"2017-01-20T07:40:00.000Z","path":"2017/01/20/py_esp_server/","text":"&emsp;&emsp;之前用lua脚本写了一个发送html的http server放在ESP里控制电路通断很好用，&emsp;&emsp;最近发现这货竟然还有专属的MicroPython 固件，作为一个pythoner,我必须要写个python版的，也方面以后加入更多的自定义功能。&emsp;&emsp;所以最近花了点时间写了一个python版的ESP power control server。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding: utf-8 -*-from machine import Pinimport socketimport networkimport webreplfrom time import sleephtml = \"\"\"&lt;h1&gt; Power switch&lt;/h1&gt;&lt;p&gt;switch1 &lt;a href=\\\"?pin=ON1\\\"&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt; &lt;a href=\\\"?pin=OFF1\\\"&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;switch2 &lt;a href=\\\"?pin=ON2\\\"&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt; &lt;a href=\\\"?pin=OFF2\\\"&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\"\"def connectwifi(): sta_if = network.WLAN(network.STA_IF) sta_if.active(True) print (\"connect WIFI, please wait...\") sleep(4) sta_if.connect(\"wifi-ssid\",\"wifi-password\") sleep(6) print(\"WIFI connected ! IP address is (\",sta_if.ifconfig()[0],\")\") webrepl.start() print(\"User init Done!\")def op1(): p2.value(0)def dn1(): p2.value(1)def op2(): print (\"switch 2 is open\")def dn2(): print (\"switch 2 is down\") p2 = Pin(2,Pin.OUT)pool = &#123;'ON1':op1,'ON2':op2,'OFF1':dn1,'OFF2':dn2&#125;def startServer(): addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1] sleep(2) s = socket.socket() sleep(2) s.bind(addr) sleep(2) s.listen(1) print('listening on', addr) sleep(2) while True: cl, addr = s.accept() cl_file = cl.makefile('rwb', 0) while True: try: line = cl_file.readline() except: continue if not line or line == b'\\r\\n': break else: firstline = str(line).split(\"\\n\")[0] if \"GET\" in firstline: for i in pool.keys(): if i in firstline: pool.get(i)() break cl.send(html) cl.close()def ok(): connectwifi() startServer()if __name__ == \"__main__\": ok() 将以上文件命名为ss.py 放入ESP 根目录按照MicroPython 的Guide的说法来做，放入一个main.py文件作为钩子来启动它：12import ssss.ok() 然后下电复位下，就可以自动连接WIFI，并建立HTTP server.外部用户通过IP地址找到它，并控制电路通断。&emsp;&emsp;&emsp;&emsp;已知问题 使用360浏览器浏览网页无法通过按钮去控制ESP，使用IE和Chrome 可以控制。 稳定性待验证，暂未做过长时间使用测试","tags":[]},{"title":"每日工作划分文件夹","date":"2016-10-08T18:08:00.000Z","path":"2016/10/09/create_daily_dir/","text":"&emsp;&emsp;经常工作的时候，每天处理大量的文件很容易混乱和丢失。&emsp;&emsp;我有个想法，每天的工作用到的文件都独立的放到一个文件夹里。这样整齐一些也方便管理。&emsp;&emsp;于是我用python写了一个小脚本。在安装了解释器的PC里只需要双击即可执行，即可生成以当天日期为名字的文件夹。 123456789101112import osimport timedef makeDIRwithDate(): timestat = timestamp = time.strftime('%Y-%m-%d',time.localtime(time.time())) existdir = os.path.exists(timestat) if not existdir: os.mkdir(timestat) print \"make dir:[%s]\" % timestat else: print 'folder[%s] already exists' % timestatmakeDIRwithDate() &emsp;&emsp;创建了文件夹后，剩下就是手工把每天用到的文件复制进去保存。效果如下图。","tags":[]},{"title":"DIY 远程控制电源模块","date":"2016-08-15T15:39:00.000Z","path":"2016/08/15/DIY_remote_power_switch/","text":"&emsp;&emsp;我们的自动化测试环境一直缺少一个可以远程控制的供电系统来控制Radio产品的开关机。之前在波兰的时候，我看到老外的自动化Lab全部采用的是商业控制产品，可使用web页面控制，也可以使用简单的协议控制（ssh或者Telnet发送简单的命令控制外部电路）。&emsp;&emsp;按照老外的配置，一套控制核心+几路ABB继电器+几路空开。我查了下报价，3000欧元一个控制中心，继电器也得300RMB一个。总体下来一万多RMB。就为了自动开个机，花销挺贵的。老板也没同意，搁置了这个想法一段时间。&emsp;&emsp;后来混树莓派论坛的时候，我发现有人在用ESP8266组装各种很屌的玩意，其中就包括可控电源开关，很有意思。我随后淘宝了几只，一只只要25块，很便宜的说。&emsp;&emsp;以下记录的就是实现可控电源开关的过程。 直接上demo图&emsp;&emsp;这个demo使用的材料有：ESP8266开发板1只+ LED灯2个 + 电阻一只 + 若干导线 + 5V继电器一枚 + 小米移动电源一个，除掉小米移动电源，花销大概是50块不到。 逻辑原理是这样的： 开发板有固定的3.3V和地，以及若干3.3V的GPIO引脚 控制信号由D1 GPIO控制，图上的黄线 经过LED的链路就是受控链路，LED可以换成任何我们想要控制上下电的设备。 受控制的链路实际上有三个端口，一个固定端口，一个常开端口，一个常闭端口。我因为需要的场景是只在需要的时候关机，所以连接了常开端口。 继电器的PIN角可以设置为用低电平触发电源断开，或者用高电平触发电源断开。经过我的尝试 如果设置为高电平触发，当D1 GPIO端口从关变为开的时候，会从0V变为+3.3V，不足5V，无法作为“高电平”来触发继电器吸合（因为我买的这个继电器是5V驱动的）。 如果设置为低电平触发，平时D1 保持常开，需要下电的时候，把D1关闭，从+3.3V变为0V，刚好是继电器认可的“低电平”。此时会触发继电器吸合。受控链路断开。电源关闭。目的达成。（PS：后面的代码是写的电源常闭） &emsp;&emsp;这里比较凑巧的是3.3V可以给继电器供电。所以就不需要再麻烦给继电器连接额外的电源，从而可以把整个装置做的很小。同时，毕竟它是一个IOT开发板，是带WIFI芯片的，可以连接路由器。参考了dingzz的 http://blog.csdn.NET/dingzz/article/details/46876503 文章加入了一个网页特性，这里init.lua的代码如下(Lua脚本)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748print('Setting up WIFI...')wifi.setmode(wifi.STATION)wifi.sta.config('WIFI_ssid', 'wifi_password')wifi.sta.connect()tmr.alarm(1,1000,1,function()if wifi.sta.getip()==nil thenprint(\"IP unavaiable,Waiting...\")elsetmr.stop(1)print(\"Config done, IP is \"..wifi.sta.getip())endend)led1 = 1led2 = 2gpio.mode(led1, gpio.OUTPUT)gpio.mode(led2, gpio.OUTPUT)srv=net.createServer(net.TCP)srv:listen(80,function(conn) conn:on(\"receive\", function(client,request) local buf = \"\"; local _, _, method, path, vars = string.find(request, \"([A-Z]+) (.+)?(.+) HTTP\"); if(method == nil)then _, _, method, path = string.find(request, \"([A-Z]+) (.+) HTTP\"); end local _GET = &#123;&#125; if (vars ~= nil)then for k, v in string.gmatch(vars, \"(%w+)=(%w+)&amp;*\") do _GET[k] = v end end buf = buf..\"&lt;h1&gt; ESP 8266 server&lt;/h1&gt;\"; buf = buf..\"&lt;p&gt;switch1 &lt;a href=\\\"?pin=ON1\\\"&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt; &lt;a href=\\\"?pin=OFF1\\\"&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"; buf = buf..\"&lt;p&gt;switch2 &lt;a href=\\\"?pin=ON2\\\"&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt; &lt;a href=\\\"?pin=OFF2\\\"&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"; local _on,_off = \"\",\"\" if(_GET.pin == \"ON1\")then gpio.write(led1, gpio.HIGH); elseif(_GET.pin == \"OFF1\")then gpio.write(led1, gpio.LOW); elseif(_GET.pin == \"ON2\")then gpio.write(led2, gpio.HIGH); elseif(_GET.pin == \"OFF2\")then gpio.write(led2, gpio.LOW); end client:send(buf); client:close(); collectgarbage(); end)end) init.lua传入开发板后，每次开机都会执行它，这是NodeMcu的设计。这里代码实现的功能就是连接WIFI，并建立了一个网页server.只要知道开发板的IP地址，就可以通过浏览器控制你想控制的电源。效果是这样的： 实验过程1. init.lua 传到ESP8266里。开机，它即可连接上指定的WIFI信号，假如PC同时连入同一个无线网，就可以简单的通过网页访问ESP8266 server。然后用浏览器打开IP地址（实际上，我之前调试的时候通过串口打印已经知道了这个IP，但是如果是首次换了脚本，直接通过外部电源开机，是不知道它的IP地址的。 2. 测试开始：插入小米电源，继电器供上了电，亮灯。从串口可以看到，大概经过10秒，ESP8266自动连上WIFI，获得IP地址，在浏览器敲入这个IP地址可以进入WEB界面。点击GPIO 0 ON，此时D1的高电平打开，但是LED并没有变化。点击GPIO 2 OFF，此时D2变为低电平，然后应该是这个下降沿触发了继电器的输出端吸合，两端连接，形成回路。LED亮起。点击GPIO 2 ON， D2变为高电平，继电器两端悬空，断开。LED灯熄灭。 实验结束&emsp;&emsp;如果和欧洲那个商用电源开关相比，不说安全和稳定性，咱这个功能也差不多了…嘿嘿，而且很便宜。&emsp;&emsp;我使用的这个继电器是松乐的5V模块，我找了我们这的电源designer给我评估下这个小装置的安全性.他认为继电器本身弱电和强电是分离的，是相对成熟的技术。所以没有什么风险。&emsp;&emsp;这样我可以经由WIFI控制直流27V 和交流220V的设备无压力。只要不是频繁开关（也不建议这样做），都是OK的。后来我又加装了一个20A空气开关，防止短路情况发生。算是加了一道防护。&emsp;&emsp;目前这个装置总是通过IP地址来控制，不太智能，我考虑后续再改进改进，比如加入一个字符串作为标志，然后通过ARP或者什么别的方式找标志，来实现“不知道IP地址”也可以建立通信的办法。埋下待续。 PS: 附上ESP 8266 原理图","tags":[]},{"title":"远程控制FSV读取EVM值","date":"2015-05-15T12:10:00.000Z","path":"2015/05/15/remote_control_FSV/","text":"&emsp;&emsp;经常要手动控制FSV测试RRH的上下行射频性能指标。重复操作太枯燥，还好查找手册发现了可以通过RJ45或者GPIB端口发送SCPI命令实现远程控制，总结命令如下 测试 TX EVM command 解释 “*RST” 复位 “INIT:CONT OFF” 初始化频谱仪模式 “SYST:DISP:UPD ON” 屏幕给出显示 “INST LTE” 初始化LTE选件 “FREQ:CENT 2140 MHz” 设置测试的中心频率为2140Mhz “CONF:DL:BW BW5_00” 设置监测5M带宽 “POW:AUTO2 ON” 打开自动调节增益 “DISP:TRAC:Y:RLEV:OFFS 42” 设置外部线损为42dbm CALC2:FEED ‘STAT:ASUM’ 进入TX总结页面 INIT:CONT OFF 设置为单次测试模式 INIT;*WAI 进行一次测试 FETC:SUMM:EVM? 读取刚刚测试的EVM平均值 FETC:SUMM:EVM:ALL:MAX? 读取EVM最大值 FETC:SUMM:EVM:ALL:MIN? 读取EVM最小值 测试 TX ACLR command 解释 “*RST” 复位 “INIT:CONT OFF” 初始化频谱仪模式 “SYST:DISP:UPD ON” 屏幕给出显示 “INST LTE” 初始化LTE选件 “FREQ:CENT “+s_Freq+”MHz” 设置中心频率 “CONF:DL:BW BW”+s_BW 设置带宽 “POW:AUTO2 ON” 打开自动控制增益 “DISP:TRAC:Y:RLEV:OFFS “+s_CableLoss 设置外部线损 “CALC2:FEED ‘SPEC:ACP’” 进入ACLR界面 “INIT:CONT OFF” 进入单次测试模式 “INIT;*WAI” 执行一次测试 “CALC1:MARK:FUNC:POW:RES?” 取得刚刚的测试结果 测试RX EVM主要是设置信号发生器，发出制定的波形文件 command 解释 “*RST” 复位 “ROSC:SOUR EXT” 使用外部时钟源 “ROSC:EXT:FREQ 10MHz” 设置外部时钟源的频率是10Mhz “ROSC:EXT:SBAN NARR” 设置外部时钟源的同步要求为狭窄 “BB:ARB:WAV:SEL ‘“+s_wavePath+”\\“+”LTE_UL_4GMaxPN18“+sBandWidth+”“+s_Modulation+”‘“ 设置本地波形文件路径 “FREQ “+s_Freq+”Mhz” + “BB:ARB:TRIG:SEQ AUTO” 设置发出的波形的频率 “BB:ARB:STAT ON” 加载刚刚选择的波形 “POW:OFFS “+s_OffSet 加入外部线损的计算 “:POW “+s_RfOutLev + “OUTP ON” 打开外部输出 写了个Python脚本，主要依靠telnet来发送上述命令实现控制和读取结果，代码放在https://github.com/yunpengb/rohde_schwarz_remote_control","tags":[]},{"title":"python 实现在cmd里执行命令","date":"2015-04-08T17:17:00.000Z","path":"2015/04/09/py_cmd/","text":"我在写脚本实现一些手动的工作自动化的过程中，有一个需求是在win的cmd里输入命令，参考一些信息实现如下： 1234567891011121314151617181920212223242526272829303132333435import osimport redir = \"FRM35.09.R01\"cmd = [\"C:\",\"cd C:\\\\Temp_a\\\\\" + dir + \"\\\\C_Element\\\\SE_RFM\\\\SS_REL3\\\\RnD\",\"dir\"]# execute command, and return the outputdef runCmd(cmd): global r r = os.popen(cmd) text = r.read() return textdef closeCmd(): r.close()# for i in range(len(cmd)): # result = runCmd(cmd[i]) # print (\"--&gt;Cmd send: %s\" % cmd[i]) # print (\"&lt;--Cmd back: %s\" % result)# closeCmd()cc = cmd[0]for i in range(1,len(cmd)): cc = cc + \"&amp;&amp;\" + cmd[i]result = runCmd(cc)print (\"--&gt;Cmd send: %s\" % cc)print (\"&lt;--Cmd back: %s\" % result)#pattern = r\"^FRM-.*?LAR\\n$\"pattern = r\"FRM-\\w*\"res = re.findall(pattern,result)print res end","tags":[]}]